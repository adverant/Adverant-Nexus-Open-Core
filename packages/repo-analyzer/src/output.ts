/**
 * Output Generator for Repository Analysis
 * Generates .arch.md and other output formats from analysis results
 *
 * @module @adverant/repo-analyzer
 */

import {
  AnalysisResult,
  RepositoryType,
  TechStack,
  ArchitecturePattern,
  Finding,
  SecurityFinding,
  Recommendation,
  Severity,
} from './types/index.js';

export interface OutputOptions {
  format: 'markdown' | 'json' | 'html';
  includeDetails?: boolean;
  includeToc?: boolean;
}

/**
 * Output Generator - Creates formatted reports from analysis results
 */
export class OutputGenerator {
  /**
   * Generate output in the specified format
   */
  generate(result: AnalysisResult, options: OutputOptions): string {
    switch (options.format) {
      case 'markdown':
        return this.generateMarkdown(result, options);
      case 'json':
        return this.generateJson(result);
      case 'html':
        return this.generateHtml(result, options);
      default:
        throw new Error(`Unsupported output format: ${options.format}`);
    }
  }

  /**
   * Generate Markdown (.arch.md) output
   */
  generateMarkdown(result: AnalysisResult, options: OutputOptions = { format: 'markdown' }): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(result));

    // Table of Contents
    if (options.includeToc !== false) {
      sections.push(this.generateToc());
    }

    // Executive Summary
    sections.push(this.generateExecutiveSummary(result));

    // Repository Info
    sections.push(this.generateRepoInfo(result));

    // Tech Stack
    sections.push(this.generateTechStackSection(result.techStack));

    // Architecture Overview
    sections.push(this.generateArchitectureSection(result));

    // Findings
    if (result.findings.length > 0) {
      sections.push(this.generateFindingsSection(result.findings));
    }

    // Security Findings
    if (result.securityFindings && result.securityFindings.length > 0) {
      sections.push(this.generateSecurityFindingsSection(result.securityFindings));
    }

    // Recommendations
    if (result.recommendations.length > 0) {
      sections.push(this.generateRecommendationsSection(result.recommendations));
    }

    // Dependencies
    sections.push(this.generateDependenciesSection(result));

    // Footer
    sections.push(this.generateFooter());

    return sections.join('\n\n');
  }

  /**
   * Generate JSON output
   */
  generateJson(result: AnalysisResult): string {
    return JSON.stringify(result, null, 2);
  }

  /**
   * Generate HTML output
   */
  generateHtml(result: AnalysisResult, options: OutputOptions): string {
    const markdown = this.generateMarkdown(result, options);
    // Simple HTML wrapper - can be enhanced with proper HTML generation
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Repository Analysis: ${result.repositoryInfo.name}</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 900px; margin: 0 auto; padding: 2rem; line-height: 1.6; }
    h1, h2, h3 { color: #333; }
    code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
    pre { background: #f4f4f4; padding: 1rem; border-radius: 5px; overflow-x: auto; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background: #f4f4f4; }
    .critical { color: #dc3545; }
    .high { color: #fd7e14; }
    .medium { color: #ffc107; }
    .low { color: #28a745; }
    .info { color: #17a2b8; }
  </style>
</head>
<body>
<pre>${this.escapeHtml(markdown)}</pre>
</body>
</html>`;
  }

  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  private generateHeader(result: AnalysisResult): string {
    const { repositoryInfo } = result;
    return `# Architecture Analysis: ${repositoryInfo.owner}/${repositoryInfo.name}

> Generated by Adverant Nexus Repository Analyzer
> Branch: \`${repositoryInfo.branch}\` | Commit: \`${repositoryInfo.commitHash?.slice(0, 7) || 'N/A'}\``;
  }

  private generateToc(): string {
    return `## Table of Contents

- [Executive Summary](#executive-summary)
- [Repository Information](#repository-information)
- [Technology Stack](#technology-stack)
- [Architecture Overview](#architecture-overview)
- [Findings](#findings)
- [Recommendations](#recommendations)
- [Dependencies](#dependencies)`;
  }

  private generateExecutiveSummary(result: AnalysisResult): string {
    const { architecture, findings, securityFindings, recommendations } = result;

    const criticalCount = findings.filter(f => f.severity === 'critical').length +
      (securityFindings?.filter(f => f.severity === 'critical').length || 0);
    const highCount = findings.filter(f => f.severity === 'high').length +
      (securityFindings?.filter(f => f.severity === 'high').length || 0);

    const riskLevel = criticalCount > 0 ? 'CRITICAL' :
      highCount > 2 ? 'HIGH' :
      highCount > 0 ? 'MEDIUM' : 'LOW';

    return `## Executive Summary

| Metric | Value |
|--------|-------|
| **Repository Type** | ${this.formatRepoType(result.detectedType)} |
| **Architecture Pattern** | ${this.formatArchPattern(architecture.pattern)} (${Math.round(architecture.patternConfidence * 100)}% confidence) |
| **Risk Level** | ${riskLevel} |
| **Total Findings** | ${findings.length + (securityFindings?.length || 0)} |
| **Critical Issues** | ${criticalCount} |
| **Recommendations** | ${recommendations.length} |`;
  }

  private generateRepoInfo(result: AnalysisResult): string {
    const { repositoryInfo, repositoryMetadata } = result;

    return `## Repository Information

| Property | Value |
|----------|-------|
| **Platform** | ${repositoryInfo.platform} |
| **URL** | ${repositoryInfo.url} |
| **Branch** | ${repositoryInfo.branch} |
| **Size** | ${this.formatBytes(repositoryMetadata.sizeBytes)} |
| **Files** | ${repositoryMetadata.fileCount.toLocaleString()} |
| **Directories** | ${repositoryMetadata.directoryCount.toLocaleString()} |
| **Contributors** | ${repositoryMetadata.contributors || 'N/A'} |`;
  }

  private generateTechStackSection(techStack: TechStack[]): string {
    if (techStack.length === 0) {
      return `## Technology Stack

No specific technologies detected.`;
    }

    const categories = this.categorizeTechStack(techStack);
    let content = `## Technology Stack\n`;

    for (const [category, techs] of Object.entries(categories)) {
      if (techs.length > 0) {
        content += `\n### ${category}\n`;
        content += techs.map(t => `- ${t}`).join('\n');
      }
    }

    return content;
  }

  private categorizeTechStack(techStack: TechStack[]): Record<string, string[]> {
    const categories: Record<string, string[]> = {
      'Languages': [],
      'Frameworks': [],
      'Databases': [],
      'Infrastructure': [],
      'Testing': [],
      'Other': [],
    };

    const languageList = ['typescript', 'javascript', 'python', 'java', 'go', 'rust', 'csharp', 'ruby', 'php', 'swift', 'kotlin'];
    const frameworkList = ['express', 'nestjs', 'fastify', 'django', 'flask', 'fastapi', 'spring', 'rails', 'laravel', 'gin', 'actix', 'react', 'vue', 'angular', 'svelte', 'nextjs', 'nuxt', 'remix', 'gatsby', 'react-native', 'flutter', 'ionic', 'capacitor'];
    const databaseList = ['postgresql', 'mysql', 'mongodb', 'redis', 'elasticsearch', 'neo4j', 'dynamodb', 'sqlite'];
    const infraList = ['docker', 'kubernetes', 'terraform', 'pulumi', 'ansible', 'helm', 'aws', 'gcp', 'azure', 'vercel', 'netlify', 'cloudflare'];
    const testingList = ['jest', 'vitest', 'pytest', 'junit', 'mocha', 'cypress', 'playwright'];

    for (const tech of techStack) {
      if (languageList.includes(tech)) {
        categories['Languages'].push(tech);
      } else if (frameworkList.includes(tech)) {
        categories['Frameworks'].push(tech);
      } else if (databaseList.includes(tech)) {
        categories['Databases'].push(tech);
      } else if (infraList.includes(tech)) {
        categories['Infrastructure'].push(tech);
      } else if (testingList.includes(tech)) {
        categories['Testing'].push(tech);
      } else {
        categories['Other'].push(tech);
      }
    }

    return categories;
  }

  private generateArchitectureSection(result: AnalysisResult): string {
    const { architecture } = result;

    let content = `## Architecture Overview

### Pattern: ${this.formatArchPattern(architecture.pattern)}

**Confidence:** ${Math.round(architecture.patternConfidence * 100)}%
`;

    // Layers
    if (architecture.layers.length > 0) {
      content += `\n### Layers\n\n`;
      for (const layer of architecture.layers) {
        content += `#### ${layer.name}\n`;
        content += `- **Type:** ${layer.type}\n`;
        content += `- **Paths:** ${layer.paths.join(', ')}\n`;
        if (layer.responsibilities.length > 0) {
          content += `- **Responsibilities:**\n`;
          content += layer.responsibilities.map(r => `  - ${r}`).join('\n') + '\n';
        }
      }
    }

    // Components
    if (architecture.components.length > 0) {
      content += `\n### Key Components\n\n`;
      content += `| Component | Type | Path |\n`;
      content += `|-----------|------|------|\n`;
      for (const comp of architecture.components.slice(0, 20)) {
        content += `| ${comp.name} | ${comp.type} | \`${comp.path}\` |\n`;
      }
      if (architecture.components.length > 20) {
        content += `\n*... and ${architecture.components.length - 20} more components*\n`;
      }
    }

    // APIs
    if (architecture.apis && architecture.apis.length > 0) {
      content += `\n### API Endpoints\n\n`;
      content += `| Method | Path | Description |\n`;
      content += `|--------|------|-------------|\n`;
      for (const api of architecture.apis.slice(0, 20)) {
        content += `| ${api.method} | \`${api.path}\` | ${api.description || '-'} |\n`;
      }
    }

    return content;
  }

  private generateFindingsSection(findings: Finding[]): string {
    if (findings.length === 0) {
      return `## Findings\n\nNo findings detected.`;
    }

    const grouped = this.groupBySeverity(findings);

    let content = `## Findings\n\n`;
    content += `**Total:** ${findings.length} findings\n\n`;

    for (const severity of ['critical', 'high', 'medium', 'low', 'info'] as Severity[]) {
      const items = grouped[severity] || [];
      if (items.length === 0) continue;

      content += `### ${this.formatSeverity(severity)} (${items.length})\n\n`;

      for (const finding of items) {
        content += `#### ${finding.title}\n\n`;
        content += `- **Type:** ${finding.findingType}\n`;
        content += `- **Severity:** ${finding.severity}\n`;
        if (finding.location) {
          content += `- **Location:** \`${finding.location}\`${finding.lineNumber ? `:${finding.lineNumber}` : ''}\n`;
        }
        content += `\n${finding.description}\n\n`;
        if (finding.recommendation) {
          content += `**Recommendation:** ${finding.recommendation}\n\n`;
        }
      }
    }

    return content;
  }

  private generateSecurityFindingsSection(findings: SecurityFinding[]): string {
    if (findings.length === 0) {
      return `## Security Findings\n\nNo security issues detected.`;
    }

    let content = `## Security Findings\n\n`;
    content += `**Total:** ${findings.length} security findings\n\n`;

    const grouped = this.groupBySeverity(findings);

    for (const severity of ['critical', 'high', 'medium', 'low', 'info'] as Severity[]) {
      const items = grouped[severity] || [];
      if (items.length === 0) continue;

      content += `### ${this.formatSeverity(severity)} (${items.length})\n\n`;

      for (const finding of items) {
        content += `#### ${finding.title}\n\n`;
        content += `- **Severity:** ${finding.severity}\n`;
        if (finding.cwe) content += `- **CWE:** ${finding.cwe}\n`;
        if (finding.owasp) content += `- **OWASP:** ${finding.owasp}\n`;
        if (finding.cvss) content += `- **CVSS:** ${finding.cvss}\n`;
        if (finding.location) {
          content += `- **Location:** \`${finding.location}\`${finding.lineNumber ? `:${finding.lineNumber}` : ''}\n`;
        }
        content += `\n${finding.description}\n\n`;
        content += `**Remediation:** ${finding.remediation}\n\n`;
      }
    }

    return content;
  }

  private generateRecommendationsSection(recommendations: Recommendation[]): string {
    if (recommendations.length === 0) {
      return `## Recommendations\n\nNo recommendations at this time.`;
    }

    let content = `## Recommendations\n\n`;

    const byPriority: Record<string, Recommendation[]> = {
      critical: [],
      high: [],
      medium: [],
      low: [],
    };

    for (const rec of recommendations) {
      byPriority[rec.priority].push(rec);
    }

    for (const priority of ['critical', 'high', 'medium', 'low']) {
      const items = byPriority[priority];
      if (items.length === 0) continue;

      content += `### ${this.formatSeverity(priority as Severity)} Priority\n\n`;

      for (const rec of items) {
        content += `#### ${rec.title}\n\n`;
        content += `- **Category:** ${rec.category}\n`;
        content += `- **Effort:** ${rec.effort}\n`;
        content += `- **Impact:** ${rec.impact}\n`;
        content += `\n${rec.description}\n\n`;
      }
    }

    return content;
  }

  private generateDependenciesSection(result: AnalysisResult): string {
    const { architecture } = result;
    const deps = architecture.dependencies;

    if (!deps || (deps.nodes.length === 0 && deps.externalDependencies.length === 0)) {
      return `## Dependencies\n\nNo dependency information available.`;
    }

    let content = `## Dependencies\n\n`;

    if (deps.externalDependencies.length > 0) {
      content += `### External Dependencies\n\n`;
      content += `| Package | Version | Type |\n`;
      content += `|---------|---------|------|\n`;

      for (const dep of deps.externalDependencies.slice(0, 50)) {
        content += `| ${dep.name} | ${dep.version} | ${dep.type} |\n`;
      }

      if (deps.externalDependencies.length > 50) {
        content += `\n*... and ${deps.externalDependencies.length - 50} more dependencies*\n`;
      }
    }

    return content;
  }

  private generateFooter(): string {
    return `---

*Generated by [Adverant Nexus Open Core](https://github.com/adverant/Adverant-Nexus-Open-Core)*
*Analysis performed at: ${new Date().toISOString()}*`;
  }

  private formatRepoType(type: RepositoryType): string {
    const labels: Record<RepositoryType, string> = {
      backend: 'Backend',
      frontend: 'Frontend',
      mobile: 'Mobile',
      'infra-as-code': 'Infrastructure as Code',
      library: 'Library',
      monorepo: 'Monorepo',
      unknown: 'Unknown',
    };
    return labels[type] || type;
  }

  private formatArchPattern(pattern: ArchitecturePattern): string {
    const labels: Record<ArchitecturePattern, string> = {
      monolith: 'Monolith',
      'layered-monolith': 'Layered Monolith',
      microservices: 'Microservices',
      serverless: 'Serverless',
      'event-driven': 'Event-Driven',
      hexagonal: 'Hexagonal (Ports & Adapters)',
      'clean-architecture': 'Clean Architecture',
      mvc: 'MVC',
      mvvm: 'MVVM',
      flux: 'Flux',
      'component-based': 'Component-Based',
      'plugin-based': 'Plugin-Based',
      unknown: 'Unknown',
    };
    return labels[pattern] || pattern;
  }

  private formatSeverity(severity: Severity | string): string {
    const labels: Record<string, string> = {
      critical: 'Critical',
      high: 'High',
      medium: 'Medium',
      low: 'Low',
      info: 'Info',
    };
    return labels[severity] || severity;
  }

  private formatBytes(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }

  private groupBySeverity<T extends { severity: Severity }>(items: T[]): Record<Severity, T[]> {
    const grouped: Record<Severity, T[]> = {
      critical: [],
      high: [],
      medium: [],
      low: [],
      info: [],
    };

    for (const item of items) {
      grouped[item.severity].push(item);
    }

    return grouped;
  }
}

export default OutputGenerator;