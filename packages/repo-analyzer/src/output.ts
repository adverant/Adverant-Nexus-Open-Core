/**
 * Output Generator
 *
 * Generates analysis output in various formats (Markdown, JSON, HTML)
 */

import type {
  AnalysisResult,
  Finding,
  TechStack,
  TypeDetectionResult,
} from './types/index.js';

export interface OutputOptions {
  format: 'markdown' | 'json' | 'html';
  includeToc?: boolean;
  includeMetadata?: boolean;
  includeTimestamp?: boolean;
}

export class OutputGenerator {
  /**
   * Generate output in the specified format
   */
  generate(result: AnalysisResult, options: OutputOptions = { format: 'markdown' }): string {
    switch (options.format) {
      case 'markdown':
        return this.generateMarkdown(result, options);
      case 'json':
        return this.generateJson(result);
      case 'html':
        return this.generateHtml(result, options);
      default:
        throw new Error(`Unsupported output format: ${options.format}`);
    }
  }

  /**
   * Generate Markdown output (.arch.md format)
   */
  generateMarkdown(result: AnalysisResult, options: Partial<OutputOptions> = {}): string {
    const lines: string[] = [];
    const includeToc = options.includeToc !== false;

    // Header
    lines.push(`# ${result.repositoryInfo?.name || 'Repository'} Architecture`);
    lines.push('');
    lines.push(`> Auto-generated by @adverant/repo-analyzer`);
    if (options.includeTimestamp !== false) {
      lines.push(`> Generated: ${new Date().toISOString()}`);
    }
    lines.push('');

    // Table of Contents
    if (includeToc) {
      lines.push('## Table of Contents');
      lines.push('');
      lines.push('- [Overview](#overview)');
      lines.push('- [Technology Stack](#technology-stack)');
      lines.push('- [Architecture](#architecture)');
      if (result.findings && result.findings.length > 0) {
        lines.push('- [Findings](#findings)');
      }
      if (result.recommendations && result.recommendations.length > 0) {
        lines.push('- [Recommendations](#recommendations)');
      }
      lines.push('');
    }

    // Overview
    lines.push('## Overview');
    lines.push('');

    if (result.detectedType) {
      lines.push(`**Repository Type:** ${this.formatRepositoryType(result.detectedType)}`);
      lines.push('');
    }

    if (result.repositoryMetadata) {
      lines.push('### Repository Statistics');
      lines.push('');
      lines.push(`| Metric | Value |`);
      lines.push(`| ------ | ----- |`);
      lines.push(`| Files | ${result.repositoryMetadata.fileCount.toLocaleString()} |`);
      lines.push(`| Directories | ${result.repositoryMetadata.directoryCount.toLocaleString()} |`);
      lines.push(`| Size | ${this.formatBytes(result.repositoryMetadata.sizeBytes)} |`);
      if (result.repositoryMetadata.lastCommitDate) {
        lines.push(`| Last Commit | ${new Date(result.repositoryMetadata.lastCommitDate).toLocaleDateString()} |`);
      }
      lines.push('');
    }

    // Technology Stack
    lines.push('## Technology Stack');
    lines.push('');

    if (result.techStack && result.techStack.length > 0) {
      const grouped = this.groupTechStack(result.techStack);

      for (const [category, techs] of Object.entries(grouped)) {
        if (techs.length > 0) {
          lines.push(`### ${category}`);
          lines.push('');
          for (const tech of techs) {
            lines.push(`- ${tech}`);
          }
          lines.push('');
        }
      }
    } else {
      lines.push('*No technology stack detected.*');
      lines.push('');
    }

    // Architecture
    lines.push('## Architecture');
    lines.push('');

    const architecture = result.architecture;
    if (architecture) {
      lines.push(`**Pattern:** ${this.formatArchitecturePattern(architecture.pattern)} (${Math.round(architecture.patternConfidence * 100)}% confidence)`);
      lines.push('');

      // Layers
      if (architecture.layers && architecture.layers.length > 0) {
        lines.push('### Layers');
        lines.push('');

        for (const layer of architecture.layers) {
          const layerName = layer.name || 'Unnamed Layer';
          const layerType = layer.type ? ` (${layer.type})` : '';
          lines.push(`#### ${layerName}${layerType}`);
          lines.push('');

          if (layer.paths && layer.paths.length > 0) {
            lines.push(`- **Paths:** ${layer.paths.join(', ')}`);
          }
          if (layer.responsibilities && layer.responsibilities.length > 0) {
            lines.push(`- **Responsibilities:** ${layer.responsibilities.join(', ')}`);
          }
          if (layer.dependencies && layer.dependencies.length > 0) {
            lines.push(`- **Dependencies:** ${layer.dependencies.join(', ')}`);
          }
          lines.push('');
        }
      }

      // Components
      if (architecture.components && architecture.components.length > 0) {
        lines.push('### Key Components');
        lines.push('');
        lines.push('| Component | Type | Path | LOC |');
        lines.push('| --------- | ---- | ---- | --- |');

        for (const component of architecture.components.slice(0, 20)) {
          const name = component.name || 'Unknown';
          const type = component.type || 'other';
          const compPath = component.path || '-';
          const loc = component.linesOfCode?.toLocaleString() || '-';
          lines.push(`| ${name} | ${type} | \`${compPath}\` | ${loc} |`);
        }
        lines.push('');

        if (architecture.components.length > 20) {
          lines.push(`*...and ${architecture.components.length - 20} more components.*`);
          lines.push('');
        }
      }

      // APIs
      if (architecture.apis && architecture.apis.length > 0) {
        lines.push('### API Endpoints');
        lines.push('');
        lines.push('| Method | Path | Description |');
        lines.push('| ------ | ---- | ----------- |');

        for (const api of architecture.apis.slice(0, 30)) {
          const method = api.method || 'GET';
          const apiPath = api.path || '/';
          const desc = api.description || '-';
          lines.push(`| \`${method}\` | \`${apiPath}\` | ${desc} |`);
        }
        lines.push('');

        if (architecture.apis.length > 30) {
          lines.push(`*...and ${architecture.apis.length - 30} more endpoints.*`);
          lines.push('');
        }
      }

      // External Dependencies
      if (architecture.dependencies?.externalDependencies &&
          architecture.dependencies.externalDependencies.length > 0) {
        lines.push('### External Dependencies');
        lines.push('');

        const prodDeps = architecture.dependencies.externalDependencies
          .filter(d => d.type === 'production')
          .slice(0, 15);

        if (prodDeps.length > 0) {
          lines.push('#### Production');
          lines.push('');
          for (const dep of prodDeps) {
            lines.push(`- \`${dep.name}\`@${dep.version}`);
          }
          lines.push('');
        }
      }
    } else {
      lines.push('*Architecture analysis not available.*');
      lines.push('');
    }

    // Findings
    if (result.findings && result.findings.length > 0) {
      lines.push('## Findings');
      lines.push('');

      const groupedFindings = this.groupFindings(result.findings);

      for (const [severity, findings] of Object.entries(groupedFindings)) {
        if (findings.length > 0) {
          lines.push(`### ${this.formatSeverity(severity)}`);
          lines.push('');

          for (const finding of findings) {
            lines.push(`- **${finding.title}**`);
            lines.push(`  - ${finding.description}`);
            if (finding.location) {
              lines.push(`  - Location: \`${finding.location}\``);
            }
            if (finding.recommendation) {
              lines.push(`  - Recommendation: ${finding.recommendation}`);
            }
          }
          lines.push('');
        }
      }
    }

    // Security Findings
    if (result.securityFindings && result.securityFindings.length > 0) {
      lines.push('## Security Findings');
      lines.push('');

      for (const finding of result.securityFindings) {
        const severity = finding.severity?.toUpperCase() || 'INFO';
        lines.push(`### [${severity}] ${finding.title}`);
        lines.push('');
        lines.push(finding.description);
        lines.push('');

        if (finding.cwe) lines.push(`- **CWE:** ${finding.cwe}`);
        if (finding.owasp) lines.push(`- **OWASP:** ${finding.owasp}`);
        if (finding.cvss) lines.push(`- **CVSS:** ${finding.cvss}`);
        if (finding.location) lines.push(`- **Location:** \`${finding.location}\``);

        lines.push('');
        lines.push(`**Remediation:** ${finding.remediation}`);
        lines.push('');
      }
    }

    // Recommendations
    if (result.recommendations && result.recommendations.length > 0) {
      lines.push('## Recommendations');
      lines.push('');

      const sortedRecs = [...result.recommendations].sort((a, b) => {
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        return (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
      });

      for (const rec of sortedRecs) {
        const priority = rec.priority?.toUpperCase() || 'LOW';
        const effort = rec.effort || 'medium';
        const impact = rec.impact || 'medium';

        lines.push(`### [${priority}] ${rec.title}`);
        lines.push('');
        lines.push(rec.description);
        lines.push('');
        lines.push(`- **Effort:** ${effort}`);
        lines.push(`- **Impact:** ${impact}`);
        lines.push('');
      }
    }

    // Directory Structure
    if (result.directoryStructure) {
      lines.push('## Directory Structure');
      lines.push('');
      lines.push('```');
      lines.push(this.formatDirectoryTree(result.directoryStructure, 0, 4));
      lines.push('```');
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate JSON output
   */
  generateJson(result: AnalysisResult): string {
    return JSON.stringify(result, null, 2);
  }

  /**
   * Generate HTML output
   */
  generateHtml(result: AnalysisResult, _options: Partial<OutputOptions> = {}): string {
    const markdown = this.generateMarkdown(result, { includeToc: true });

    // Convert markdown to simple HTML
    const htmlBody = this.markdownToHtml(markdown);

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${result.repositoryInfo?.name || 'Repository'} Architecture</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      line-height: 1.6;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      color: #333;
    }
    h1, h2, h3 { color: #1a1a1a; }
    h1 { border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
    h2 { border-bottom: 1px solid #eee; padding-bottom: 0.3rem; margin-top: 2rem; }
    table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; text-align: left; }
    th { background-color: #f5f5f5; }
    code { background-color: #f5f5f5; padding: 0.2rem 0.4rem; border-radius: 3px; font-size: 0.9em; }
    pre { background-color: #f5f5f5; padding: 1rem; border-radius: 5px; overflow-x: auto; }
    blockquote { border-left: 4px solid #ddd; margin: 0; padding-left: 1rem; color: #666; }
    .severity-critical { color: #dc3545; font-weight: bold; }
    .severity-high { color: #fd7e14; font-weight: bold; }
    .severity-medium { color: #ffc107; }
    .severity-low { color: #28a745; }
  </style>
</head>
<body>
${htmlBody}
</body>
</html>`;
  }

  /**
   * Simple markdown to HTML conversion
   */
  private markdownToHtml(markdown: string): string {
    let html = markdown
      // Escape HTML
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      // Headers
      .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      // Bold
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      // Italic
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      // Code blocks
      .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
      // Inline code
      .replace(/`([^`]+)`/g, '<code>$1</code>')
      // Blockquotes
      .replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>')
      // Tables (simplified)
      .replace(/^\| (.+) \|$/gm, (_match, content) => {
        const cells = content.split(' | ').map((cell: string) => `<td>${cell.trim()}</td>`).join('');
        return `<tr>${cells}</tr>`;
      })
      // List items
      .replace(/^- (.+)$/gm, '<li>$1</li>')
      // Paragraphs (double newlines)
      .replace(/\n\n/g, '</p><p>')
      // Single newlines to <br>
      .replace(/\n/g, '<br>');

    // Wrap list items
    html = html.replace(/(<li>.*<\/li>)+/g, '<ul>$&</ul>');

    // Wrap table rows
    html = html.replace(/(<tr>.*<\/tr>)+/g, '<table>$&</table>');

    // Add paragraph wrapper
    html = `<p>${html}</p>`;

    return html;
  }

  /**
   * Format repository type for display
   */
  private formatRepositoryType(detection: TypeDetectionResult): string {
    const typeNames: Record<string, string> = {
      backend: 'Backend Service',
      frontend: 'Frontend Application',
      mobile: 'Mobile Application',
      'infra-as-code': 'Infrastructure as Code',
      library: 'Library/Package',
      monorepo: 'Monorepo',
      unknown: 'Unknown',
    };

    const name = typeNames[detection.primaryType] || detection.primaryType;
    const confidence = Math.round(detection.confidence * 100);

    let result = `${name} (${confidence}% confidence)`;

    if (detection.subTypes && detection.subTypes.length > 0) {
      const subTypeNames = detection.subTypes.map(t => typeNames[t] || t).join(', ');
      result += ` - Contains: ${subTypeNames}`;
    }

    return result;
  }

  /**
   * Format architecture pattern for display
   */
  private formatArchitecturePattern(pattern: string): string {
    const patternNames: Record<string, string> = {
      monolith: 'Monolith',
      'layered-monolith': 'Layered Monolith',
      microservices: 'Microservices',
      serverless: 'Serverless',
      'event-driven': 'Event-Driven',
      hexagonal: 'Hexagonal Architecture',
      'clean-architecture': 'Clean Architecture',
      mvc: 'MVC',
      mvvm: 'MVVM',
      flux: 'Flux/Redux',
      'component-based': 'Component-Based',
      'plugin-based': 'Plugin-Based',
      unknown: 'Unknown',
    };

    return patternNames[pattern] || pattern;
  }

  /**
   * Format bytes to human readable
   */
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
  }

  /**
   * Group tech stack by category
   */
  private groupTechStack(techStack: TechStack[]): Record<string, string[]> {
    const categories: Record<string, TechStack[]> = {
      'Languages': [],
      'Frameworks': [],
      'Databases': [],
      'Infrastructure': [],
      'Testing': [],
      'Other': [],
    };

    const categoryMap: Record<TechStack, string> = {
      typescript: 'Languages',
      javascript: 'Languages',
      python: 'Languages',
      java: 'Languages',
      go: 'Languages',
      rust: 'Languages',
      csharp: 'Languages',
      ruby: 'Languages',
      php: 'Languages',
      swift: 'Languages',
      kotlin: 'Languages',
      express: 'Frameworks',
      nestjs: 'Frameworks',
      fastify: 'Frameworks',
      django: 'Frameworks',
      flask: 'Frameworks',
      fastapi: 'Frameworks',
      spring: 'Frameworks',
      rails: 'Frameworks',
      laravel: 'Frameworks',
      gin: 'Frameworks',
      actix: 'Frameworks',
      react: 'Frameworks',
      vue: 'Frameworks',
      angular: 'Frameworks',
      svelte: 'Frameworks',
      nextjs: 'Frameworks',
      nuxt: 'Frameworks',
      remix: 'Frameworks',
      gatsby: 'Frameworks',
      'react-native': 'Frameworks',
      flutter: 'Frameworks',
      swiftui: 'Frameworks',
      'jetpack-compose': 'Frameworks',
      ionic: 'Frameworks',
      capacitor: 'Frameworks',
      postgresql: 'Databases',
      mysql: 'Databases',
      mongodb: 'Databases',
      redis: 'Databases',
      elasticsearch: 'Databases',
      neo4j: 'Databases',
      dynamodb: 'Databases',
      sqlite: 'Databases',
      docker: 'Infrastructure',
      kubernetes: 'Infrastructure',
      terraform: 'Infrastructure',
      pulumi: 'Infrastructure',
      ansible: 'Infrastructure',
      helm: 'Infrastructure',
      aws: 'Infrastructure',
      gcp: 'Infrastructure',
      azure: 'Infrastructure',
      vercel: 'Infrastructure',
      netlify: 'Infrastructure',
      cloudflare: 'Infrastructure',
      jest: 'Testing',
      vitest: 'Testing',
      pytest: 'Testing',
      junit: 'Testing',
      mocha: 'Testing',
      cypress: 'Testing',
      playwright: 'Testing',
      graphql: 'Other',
      rest: 'Other',
      grpc: 'Other',
      websocket: 'Other',
      openapi: 'Other',
    };

    for (const tech of techStack) {
      const category = categoryMap[tech] || 'Other';
      categories[category]?.push(tech);
    }

    // Filter out empty categories and convert to string arrays
    const result: Record<string, string[]> = {};
    for (const [category, techs] of Object.entries(categories)) {
      if (techs.length > 0) {
        result[category] = techs as string[];
      }
    }

    return result;
  }

  /**
   * Group findings by severity
   */
  private groupFindings(findings: Finding[]): Record<string, Finding[]> {
    const groups: Record<string, Finding[]> = {
      critical: [],
      high: [],
      medium: [],
      low: [],
      info: [],
    };

    for (const finding of findings) {
      const severity = finding.severity || 'info';
      groups[severity]?.push(finding);
    }

    return groups;
  }

  /**
   * Format severity for display
   */
  private formatSeverity(severity: string): string {
    const severityNames: Record<string, string> = {
      critical: 'üî¥ Critical',
      high: 'üü† High',
      medium: 'üü° Medium',
      low: 'üü¢ Low',
      info: '‚ÑπÔ∏è Info',
    };

    return severityNames[severity] || severity;
  }

  /**
   * Format directory tree
   */
  private formatDirectoryTree(
    node: { name: string; type: string; children?: Array<{ name: string; type: string; children?: unknown[] }> },
    depth: number,
    maxDepth: number
  ): string {
    if (depth >= maxDepth) return '';

    const indent = '  '.repeat(depth);
    const prefix = depth === 0 ? '' : '‚îú‚îÄ‚îÄ ';
    const icon = node.type === 'directory' ? 'üìÅ ' : 'üìÑ ';

    let result = `${indent}${prefix}${icon}${node.name}\n`;

    if (node.type === 'directory' && node.children) {
      for (const child of node.children) {
        result += this.formatDirectoryTree(child as typeof node, depth + 1, maxDepth);
      }
    }

    return result;
  }
}

export default OutputGenerator;
